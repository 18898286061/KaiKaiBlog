# 结构化编程
引用自维基百科：

`结构化程式设计（Structured programming），一种编程典范。
它采用子程序、程式码区块、for回圈以及while回圈等结构，来取代传统的 goto。
希望借此来改善计算机程序的明晰性、品质以及开发时间，并且避免写出面条式代码。`

1. 一行一行的执行
2. 有条件控制语句（if...else...）
3. 有循环控制语句 while(exp) do...

# 伪代码

## 好处： 
1. 不用纠结于语法的细节，因为语法是你自己定的
2. 可以体会语言设计者的想法，因为语法是你自己定的

举栗子：

1. `a <- 1` ：表示将 1 拷贝给 a

2. 条件控制语句：
```
  if xxx
      1
  elseif yyy
      2
  else
      3
  end
```

3. 循环语句：
```
  n <- 0
  while n < 10
      print n
      n <- n+1
  end
```

4. 从正整数组 a 中找出最小的数字，打印出来
```
a <- {
    '0': 23
    '1': 43
    '2': 239
    '3': 1321
    '4': 90
    'length': 5
}
min <-  a['0']
index <- 1
while index < a['length']
    if a[index] < min
        min <- a[index]
    end
    index <- index + 1
end
print min
```


# 流程图：

以特定的图形符号加上说明，表示算法的图，称为流程图

1. 为便于识别，绘制流程图的习惯做法是：
  - 圆角矩形表示“开始”与“结束”；
  - 矩形表示行动方案、普通工作环节用；
  - 菱形表示问题判断或判定（审核/审批/评审）环节；
  - 用平行四边形表示输入输出；
  - 箭头代表工作流方向。



# 算法

>什么是算法??

高德纳在他的著作《计算机程序设计艺术》里对算法的特征归纳到：
 - `输入`：一个算法必须有零个或以上输入量。
 - `输出`：一个算法应有一个或以上输出量，输出量是算法计算的结果。
 - `明确性`：算法的描述必须无歧义，以保证算法的实际执行结果是精确地匹配要求或期望，通常要求实际运行结果是确定的。
 - `有限性`：依据图灵的定义，一个算法是能够被任何图灵完备系统模拟的一串运算，而图灵机只有有限个状态、有限个输入符号和有限个转移函数（指令）。而一些定义更规定算法必须在有限个步骤内完成任务。
 - `有效性`：又称可行性。能够实现，算法中描述的操作都是可以通过已经实现的基本运算执行有限次来实现。








# 数据结构
>什么是数据结构??

数据结构就是“数据的结构”

一般来说是这样的：

1. 我们要解决一个跟数据相关的问题
2. 分析这个问题，想出对应的数据结构
3. 分析数据结构，想出算法
4. 数据结构和算法是互相依存、不可分开的

## 算法的分类

分治法：把一个问题分区成互相独立的多个部分分别求解的思路。这种求解思路带来的好处之一是便于进行并行计算。
动态规划法：当问题的整体最优解就是由局部最优解组成的时候，经常采用的一种方法。
贪婪算法：常见的近似求解思路。当问题的整体最优解不是（或无法证明是）由局部最优解组成，且对解的最优性没有要求的时候，可以采用的一种方法。
线性规划法：见词条。
简并法：把一个问题通过逻辑或数学推理，简化成与之等价或者近似的、相对简单的模型，进而求解的方法。

而前端主要使用分治法——分而治之。










## 排序算法

1. 冒泡排序

第一次循环：为轮数
第二次循环：为第几个在对比

伪代码：
```
轮数 <- 0

arr <- [3, 2, 4, 9, 1, 5, 7, 6, 8]
while (轮数 < arr['length']) 
  for (第几个 <- 0; 第几个 < arr['length'] - 轮数; 第几个++) 
    if (arr[第几个] > arr[第几个 + 1]) 
        temp <- arr[第几个]
        arr[第几个] <- arr[第几个 + 1];
        arr[第几个 + 1] <- temp
    end
    轮数 <- 轮数 + 1
  end
  pritf(arr);

```







2. 选择排序

伪代码：
```
arr <- [3, 2, 4, 9, 1, 5, 7, 6, 8]
for ( i = 0; i < arr['length'] - 1; i++)
  最小的下标 = i;
  for (j = i + 1; j < arr['length']; j++)
    if (arr[j] < arr[最小的下标])
      最小的下标 = j
  end
  temp = arr[i];
  arr[i] = arr[最小的下标];
  arr[最小的下标] = temp;
end
print arr;
```


3. 插入排序
4. 快速排序
5. 基数排序
6. 归并排序
7. 堆排序
8. 计数排序
伪代码：

```
a <- {
    '0':0,
    '1':2,
    '2':1,
    '3':56,
    '4':4,
    '5':67,
    '6':3,
    'length:7'
}
hash <- {}
index <- 0
while index < a['length']
    number <- a[index]
    if hash[number] == undefined // hash[number] 不存在
        hash[number] = 1
    else
        hash[number] <- hash[number] + 1
    end
    index <- index + 1
end

index2 <- 0
max <- findMax(a) // 最大值67
newArr <- {}
while index2 < max + 1
    count <- hash[index2]
    if count != undefined // count 存在
        countIndex <- 0
        while countIndex < count
            newArr.push(index2)
            countIndex <- countIndex + 1
        end
    end
    index2 <- index2 + 1
end
print newArr

```




排序可视化：https://visualgo.net/bn/sorting








